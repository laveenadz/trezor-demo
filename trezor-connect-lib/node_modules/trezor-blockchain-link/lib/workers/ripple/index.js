'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _rippleLib = require('ripple-lib');

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

var _constants = require('../../constants');

var _common = require('../common');

var common = _interopRequireWildcard(_common);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _messages = require('../../types/messages');

var MessageTypes = _interopRequireWildcard(_messages);

var _responses = require('../../types/responses');

var ResponseTypes = _interopRequireWildcard(_responses);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// WebWorker message handling
onmessage = function onmessage(event) {
    if (!event.data) return;
    var data = event.data;


    common.debug('onmessage', data);
    switch (data.type) {
        case _constants.MESSAGES.HANDSHAKE:
            common.setSettings(data.settings);
            break;
        case _constants.MESSAGES.CONNECT:
            connect().then(function () {
                var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(api) {
                    var block;
                    return _regenerator2.default.wrap(function _callee$(_context) {
                        while (1) {
                            switch (_context.prev = _context.next) {
                                case 0:
                                    _context.next = 2;
                                    return api.connection.getLedgerVersion();

                                case 2:
                                    block = _context.sent;

                                    common.response({ id: data.id, type: _constants.RESPONSES.CONNECT, payload: true });

                                case 4:
                                case 'end':
                                    return _context.stop();
                            }
                        }
                    }, _callee, undefined);
                }));

                return function (_x) {
                    return _ref.apply(this, arguments);
                };
            }()).catch(function (error) {
                return common.errorHandler({ id: data.id, error: error });
            });
            break;
        case _constants.MESSAGES.GET_INFO:
            getInfo(data);
            break;
        case _constants.MESSAGES.GET_ACCOUNT_INFO:
            getAccountInfo(data);
            break;
        case _constants.MESSAGES.ESTIMATE_FEE:
            estimateFee(data);
            break;
        case _constants.MESSAGES.PUSH_TRANSACTION:
            pushTransaction(data);
            break;
        case _constants.MESSAGES.SUBSCRIBE:
            subscribe(data);
            break;
        case _constants.MESSAGES.UNSUBSCRIBE:
            unsubscribe(data);
            break;
        case _constants.MESSAGES.DISCONNECT:
            disconnect(data);
            break;
        default:
            common.errorHandler({
                id: data.id,
                error: new Error('Unknown message type ' + data.type)
            });
            break;
    }
};

var _api = void 0;
var _pingTimeout = void 0;
var _endpoints = [];
var RESERVE = {
    BASE: '20000000',
    OWNER: '5000000'
};
var BLOCKS = {
    MIN: 0,
    MAX: 0
};
var TX_LIMIT = 100;

var timeoutHandler = function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (!(_api && _api.isConnected())) {
                            _context2.next = 10;
                            break;
                        }

                        _context2.prev = 1;
                        _context2.next = 4;
                        return _api.getServerInfo();

                    case 4:
                        _pingTimeout = setTimeout(timeoutHandler, 5000);
                        _context2.next = 10;
                        break;

                    case 7:
                        _context2.prev = 7;
                        _context2.t0 = _context2['catch'](1);

                        common.debug('Error in timeout ping request: ' + _context2.t0);

                    case 10:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, undefined, [[1, 7]]);
    }));

    return function timeoutHandler() {
        return _ref2.apply(this, arguments);
    };
}();

var connect = function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        var api, availableBlocks, info, _availableBlocks;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        if (!_api) {
                            _context3.next = 3;
                            break;
                        }

                        if (!_api.isConnected()) {
                            _context3.next = 3;
                            break;
                        }

                        return _context3.abrupt('return', _api);

                    case 3:
                        if (!(common.getSettings().server.length < 1)) {
                            _context3.next = 5;
                            break;
                        }

                        throw new Error('No servers');

                    case 5:

                        if (_endpoints.length < 1) {
                            _endpoints = common.getSettings().server.slice(0);
                        }

                        common.debug('Connecting to', _endpoints[0]);
                        api = new _rippleLib.RippleAPI({ server: _endpoints[0] });
                        _context3.prev = 8;
                        _context3.next = 11;
                        return api.connect();

                    case 11:
                        _context3.next = 23;
                        break;

                    case 13:
                        _context3.prev = 13;
                        _context3.t0 = _context3['catch'](8);

                        common.debug('Websocket connection failed');
                        _api = undefined;
                        // connection error. remove endpoint
                        _endpoints.splice(0, 1);
                        // and try another one or throw error

                        if (!(_endpoints.length < 1)) {
                            _context3.next = 20;
                            break;
                        }

                        throw new Error('All backends are down');

                    case 20:
                        _context3.next = 22;
                        return connect();

                    case 22:
                        return _context3.abrupt('return', _context3.sent);

                    case 23:

                        // disable reconnecting
                        // workaround: RippleApi which doesn't have possibility to disable reconnection
                        // override private method and return never ending promise
                        api.connection._retryConnect = function () {
                            return new Promise(function () {});
                        };

                        api.on('ledger', function (ledger) {
                            clearTimeout(_pingTimeout);
                            _pingTimeout = setTimeout(timeoutHandler, 5000);

                            // store current block/ledger values
                            RESERVE.BASE = api.xrpToDrops(ledger.reserveBaseXRP);
                            RESERVE.OWNER = api.xrpToDrops(ledger.reserveIncrementXRP);
                            var availableBlocks = ledger.validatedLedgerVersions.split('-');
                            BLOCKS.MIN = parseInt(availableBlocks[0]);
                            BLOCKS.MAX = parseInt(availableBlocks[1]);
                        });

                        api.on('disconnected', function () {
                            clearTimeout(_pingTimeout);
                            cleanup();
                            common.response({ id: -1, type: _constants.RESPONSES.DISCONNECTED, payload: true });
                        });

                        // mocking
                        // setTimeout(() => {
                        //     api.connection._ws._ws.close()
                        // }, 6000);

                        _context3.prev = 26;
                        availableBlocks = api.connection._availableLedgerVersions.serialize().split('-');

                        BLOCKS.MIN = parseInt(availableBlocks[0]);
                        BLOCKS.MAX = parseInt(availableBlocks[1]);
                        _context3.next = 40;
                        break;

                    case 32:
                        _context3.prev = 32;
                        _context3.t1 = _context3['catch'](26);
                        _context3.next = 36;
                        return api.getServerInfo();

                    case 36:
                        info = _context3.sent;
                        _availableBlocks = info.completeLedgers.split('-');

                        BLOCKS.MIN = parseInt(_availableBlocks[0]);
                        BLOCKS.MAX = parseInt(_availableBlocks[1]);

                    case 40:

                        common.response({ id: -1, type: _constants.RESPONSES.CONNECTED });

                        _api = api;
                        return _context3.abrupt('return', _api);

                    case 43:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, _callee3, undefined, [[8, 13], [26, 32]]);
    }));

    return function connect() {
        return _ref3.apply(this, arguments);
    };
}();

var cleanup = function cleanup() {
    if (_api) {
        _api.removeAllListeners();
        _api = undefined;
    }
    common.removeAddresses(common.getAddresses());
    common.clearSubscriptions();
};

var getInfo = function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(data) {
        var api, info, block;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        _context4.prev = 0;
                        _context4.next = 3;
                        return connect();

                    case 3:
                        api = _context4.sent;
                        _context4.next = 6;
                        return api.getServerInfo();

                    case 6:
                        info = _context4.sent;
                        _context4.next = 9;
                        return api.getLedgerVersion();

                    case 9:
                        block = _context4.sent;

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.GET_INFO,
                            payload: {
                                name: 'Ripple',
                                shortcut: 'xrp',
                                decimals: 6,
                                block: block,
                                fee: '',
                                reserved: '0'
                            }
                        });
                        _context4.next = 16;
                        break;

                    case 13:
                        _context4.prev = 13;
                        _context4.t0 = _context4['catch'](0);

                        common.errorHandler({ id: data.id, error: _context4.t0 });

                    case 16:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, _callee4, undefined, [[0, 13]]);
    }));

    return function getInfo(_x2) {
        return _ref4.apply(this, arguments);
    };
}();

// Custom request
// RippleApi doesn't support "ledger_index": "current", which will fetch data from mempool
var getMempoolAccountInfo = function () {
    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(account) {
        var api, info;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        _context5.next = 2;
                        return connect();

                    case 2:
                        api = _context5.sent;
                        _context5.next = 5;
                        return api.request('account_info', {
                            account: account,
                            ledger_index: 'current',
                            queue: true
                        });

                    case 5:
                        info = _context5.sent;
                        return _context5.abrupt('return', {
                            xrpBalance: info.account_data.Balance,
                            sequence: info.account_data.Sequence
                        });

                    case 7:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, _callee5, undefined);
    }));

    return function getMempoolAccountInfo(_x3) {
        return _ref5.apply(this, arguments);
    };
}();

// Custom request
// RippleApi returns parsed/formatted transactions, use own parsing
var getRawTransactions = function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(account, options) {
        var api, raw;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
                switch (_context6.prev = _context6.next) {
                    case 0:
                        _context6.next = 2;
                        return connect();

                    case 2:
                        api = _context6.sent;
                        _context6.next = 5;
                        return api.request('account_tx', {
                            account: account,
                            ledger_index_max: options.maxLedgerVersion,
                            ledger_index_min: options.minLedgerVersion,
                            limit: options.limit
                        });

                    case 5:
                        raw = _context6.sent;
                        return _context6.abrupt('return', raw.transactions.map(function (tx) {
                            return utils.transformTransactionHistory(account, tx);
                        }));

                    case 7:
                    case 'end':
                        return _context6.stop();
                }
            }
        }, _callee6, undefined);
    }));

    return function getRawTransactions(_x4, _x5) {
        return _ref6.apply(this, arguments);
    };
}();

var getAccountInfo = function () {
    var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(data) {
        var payload, options, account, api, info, ownersReserve, mempoolInfo, _api2, block, minLedgerVersion, maxLedgerVersion, fetchAll, requestOptions, transactions, hasNextPage, response;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
            while (1) {
                switch (_context7.prev = _context7.next) {
                    case 0:
                        payload = data.payload;
                        options = payload.options || {};
                        account = {
                            address: payload.descriptor,
                            transactions: 0,
                            block: 0,
                            balance: '0',
                            availableBalance: '0',
                            reserve: RESERVE.BASE,
                            sequence: 0
                        };
                        _context7.prev = 3;
                        _context7.next = 6;
                        return connect();

                    case 6:
                        api = _context7.sent;

                        account.block = BLOCKS.MAX;

                        _context7.next = 10;
                        return api.getAccountInfo(payload.descriptor);

                    case 10:
                        info = _context7.sent;
                        ownersReserve = info.ownerCount > 0 ? new _bignumber2.default(info.ownerCount).multipliedBy(RESERVE.OWNER).toString() : '0';

                        account.balance = api.xrpToDrops(info.xrpBalance);
                        account.availableBalance = account.balance;
                        account.sequence = info.sequence;
                        account.reserve = new _bignumber2.default(RESERVE.BASE).plus(ownersReserve).toString();
                        _context7.next = 22;
                        break;

                    case 18:
                        _context7.prev = 18;
                        _context7.t0 = _context7['catch'](3);

                        // empty account throws error "actNotFound"
                        // catch it and respond with empty account
                        if (_context7.t0.message === 'actNotFound') {
                            common.response({
                                id: data.id,
                                type: _constants.RESPONSES.GET_ACCOUNT_INFO,
                                payload: account
                            });
                        } else {
                            common.errorHandler({ id: data.id, error: _context7.t0 });
                        }
                        return _context7.abrupt('return');

                    case 22:
                        _context7.prev = 22;
                        _context7.next = 25;
                        return getMempoolAccountInfo(payload.descriptor);

                    case 25:
                        mempoolInfo = _context7.sent;

                        account.availableBalance = mempoolInfo.xrpBalance;
                        account.sequence = mempoolInfo.sequence;
                        _context7.next = 34;
                        break;

                    case 30:
                        _context7.prev = 30;
                        _context7.t1 = _context7['catch'](22);

                        common.errorHandler({ id: data.id, error: _context7.t1 });
                        return _context7.abrupt('return');

                    case 34:
                        if (!(options.type !== 'transactions')) {
                            _context7.next = 37;
                            break;
                        }

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.GET_ACCOUNT_INFO,
                            payload: account
                        });
                        return _context7.abrupt('return');

                    case 37:
                        _context7.prev = 37;
                        _context7.next = 40;
                        return connect();

                    case 40:
                        _api2 = _context7.sent;
                        _context7.next = 43;
                        return _api2.getLedgerVersion();

                    case 43:
                        block = _context7.sent;
                        minLedgerVersion = options.from ? Math.max(options.from, BLOCKS.MIN) : BLOCKS.MIN;
                        maxLedgerVersion = options.to ? Math.max(options.to, BLOCKS.MAX) : undefined;
                        // determines if there is bottom limit

                        fetchAll = typeof options.limit !== 'number';
                        requestOptions = {
                            minLedgerVersion: minLedgerVersion,
                            maxLedgerVersion: maxLedgerVersion,
                            limit: fetchAll ? TX_LIMIT : options.limit
                        };
                        transactions = [];

                        if (fetchAll) {
                            _context7.next = 55;
                            break;
                        }

                        _context7.next = 52;
                        return getRawTransactions(payload.descriptor, requestOptions);

                    case 52:
                        transactions = _context7.sent;
                        _context7.next = 65;
                        break;

                    case 55:
                        // get all pages at once
                        hasNextPage = true;

                    case 56:
                        if (!hasNextPage) {
                            _context7.next = 65;
                            break;
                        }

                        _context7.next = 59;
                        return getRawTransactions(payload.descriptor, requestOptions);

                    case 59:
                        response = _context7.sent;

                        transactions = utils.concatTransactions(transactions, response);
                        // hasNextPage = response.length >= TX_LIMIT && transactions.length < 10000;
                        hasNextPage = response.length >= TX_LIMIT;
                        if (hasNextPage) {
                            requestOptions.maxLedgerVersion = response[response.length - 1].blockHeight;
                        }
                        _context7.next = 56;
                        break;

                    case 65:

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.GET_ACCOUNT_INFO,
                            payload: (0, _extends3.default)({}, account, {
                                transactions: transactions,
                                block: block
                            })
                        });
                        _context7.next = 71;
                        break;

                    case 68:
                        _context7.prev = 68;
                        _context7.t2 = _context7['catch'](37);

                        common.errorHandler({ id: data.id, error: _context7.t2 });

                    case 71:
                    case 'end':
                        return _context7.stop();
                }
            }
        }, _callee7, undefined, [[3, 18], [22, 30], [37, 68]]);
    }));

    return function getAccountInfo(_x6) {
        return _ref7.apply(this, arguments);
    };
}();

var estimateFee = function () {
    var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(data) {
        var api, fee, drops, payload;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
            while (1) {
                switch (_context8.prev = _context8.next) {
                    case 0:
                        _context8.prev = 0;
                        _context8.next = 3;
                        return connect();

                    case 3:
                        api = _context8.sent;
                        _context8.next = 6;
                        return api.getFee();

                    case 6:
                        fee = _context8.sent;

                        // TODO: sometimes rippled returns very high values in "server_info.load_factor" and calculated fee jumps from basic 12 drops to 6000+ drops for a moment
                        // investigate more...
                        drops = api.xrpToDrops(fee);
                        payload = data.payload && Array.isArray(data.payload.levels) ? data.payload.levels.map(function (l) {
                            return { name: l.name, value: drops };
                        }) : [{ name: 'Normal', value: drops }];

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.ESTIMATE_FEE,
                            payload: payload
                        });
                        _context8.next = 15;
                        break;

                    case 12:
                        _context8.prev = 12;
                        _context8.t0 = _context8['catch'](0);

                        common.errorHandler({ id: data.id, error: _context8.t0 });

                    case 15:
                    case 'end':
                        return _context8.stop();
                }
            }
        }, _callee8, undefined, [[0, 12]]);
    }));

    return function estimateFee(_x7) {
        return _ref8.apply(this, arguments);
    };
}();

var pushTransaction = function () {
    var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(data) {
        var api, info;
        return _regenerator2.default.wrap(function _callee9$(_context9) {
            while (1) {
                switch (_context9.prev = _context9.next) {
                    case 0:
                        _context9.prev = 0;
                        _context9.next = 3;
                        return connect();

                    case 3:
                        api = _context9.sent;
                        _context9.next = 6;
                        return api.submit(data.payload.toUpperCase());

                    case 6:
                        info = _context9.sent;

                        if (!(info.resultCode === 'tesSUCCESS')) {
                            _context9.next = 11;
                            break;
                        }

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.PUSH_TRANSACTION,
                            payload: info.resultMessage
                        });
                        _context9.next = 13;
                        break;

                    case 11:
                        common.errorHandler({ id: data.id, error: new Error(info.resultMessage) });
                        return _context9.abrupt('return');

                    case 13:
                        _context9.next = 18;
                        break;

                    case 15:
                        _context9.prev = 15;
                        _context9.t0 = _context9['catch'](0);

                        common.errorHandler({ id: data.id, error: _context9.t0 });

                    case 18:
                    case 'end':
                        return _context9.stop();
                }
            }
        }, _callee9, undefined, [[0, 15]]);
    }));

    return function pushTransaction(_x8) {
        return _ref9.apply(this, arguments);
    };
}();

var subscribe = function () {
    var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(data) {
        var payload;
        return _regenerator2.default.wrap(function _callee10$(_context10) {
            while (1) {
                switch (_context10.prev = _context10.next) {
                    case 0:
                        payload = data.payload;
                        _context10.prev = 1;

                        if (!(payload.type === 'notification')) {
                            _context10.next = 7;
                            break;
                        }

                        _context10.next = 5;
                        return subscribeAddresses(payload.addresses, payload.mempool);

                    case 5:
                        _context10.next = 10;
                        break;

                    case 7:
                        if (!(payload.type === 'block')) {
                            _context10.next = 10;
                            break;
                        }

                        _context10.next = 10;
                        return subscribeBlock();

                    case 10:
                        _context10.next = 16;
                        break;

                    case 12:
                        _context10.prev = 12;
                        _context10.t0 = _context10['catch'](1);

                        common.errorHandler({ id: data.id, error: _context10.t0 });
                        return _context10.abrupt('return');

                    case 16:

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.SUBSCRIBE,
                            payload: true
                        });

                    case 17:
                    case 'end':
                        return _context10.stop();
                }
            }
        }, _callee10, undefined, [[1, 12]]);
    }));

    return function subscribe(_x9) {
        return _ref10.apply(this, arguments);
    };
}();

var subscribeAddresses = function () {
    var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(addresses) {
        var mempool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var api, uniqueAddresses, request;
        return _regenerator2.default.wrap(function _callee11$(_context11) {
            while (1) {
                switch (_context11.prev = _context11.next) {
                    case 0:
                        _context11.next = 2;
                        return connect();

                    case 2:
                        api = _context11.sent;

                        if (!common.getSubscription('transaction')) {
                            api.connection.on('transaction', onTransaction);
                            // api.connection.on('ledgerClosed', onLedgerClosed);
                            common.addSubscription('transaction');
                        }

                        uniqueAddresses = common.addAddresses(addresses);

                        if (!(uniqueAddresses.length > 0)) {
                            _context11.next = 9;
                            break;
                        }

                        request = {
                            // stream: ['transactions', 'transactions_proposed'],
                            accounts: uniqueAddresses,
                            accounts_proposed: mempool ? uniqueAddresses : []
                        };
                        _context11.next = 9;
                        return api.request('subscribe', request);

                    case 9:
                    case 'end':
                        return _context11.stop();
                }
            }
        }, _callee11, undefined);
    }));

    return function subscribeAddresses(_x11) {
        return _ref11.apply(this, arguments);
    };
}();

var subscribeBlock = function () {
    var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
        var api;
        return _regenerator2.default.wrap(function _callee12$(_context12) {
            while (1) {
                switch (_context12.prev = _context12.next) {
                    case 0:
                        if (!common.getSubscription('ledger')) {
                            _context12.next = 2;
                            break;
                        }

                        return _context12.abrupt('return');

                    case 2:
                        _context12.next = 4;
                        return connect();

                    case 4:
                        api = _context12.sent;

                        api.on('ledger', onNewBlock);
                        common.addSubscription('ledger');

                    case 7:
                    case 'end':
                        return _context12.stop();
                }
            }
        }, _callee12, undefined);
    }));

    return function subscribeBlock() {
        return _ref12.apply(this, arguments);
    };
}();

var unsubscribe = function () {
    var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(data) {
        var payload;
        return _regenerator2.default.wrap(function _callee13$(_context13) {
            while (1) {
                switch (_context13.prev = _context13.next) {
                    case 0:
                        payload = data.payload;
                        _context13.prev = 1;

                        if (!(payload.type === 'notification')) {
                            _context13.next = 7;
                            break;
                        }

                        _context13.next = 5;
                        return unsubscribeAddresses(payload.addresses);

                    case 5:
                        _context13.next = 10;
                        break;

                    case 7:
                        if (!(payload.type === 'block')) {
                            _context13.next = 10;
                            break;
                        }

                        _context13.next = 10;
                        return unsubscribeBlock();

                    case 10:
                        _context13.next = 16;
                        break;

                    case 12:
                        _context13.prev = 12;
                        _context13.t0 = _context13['catch'](1);

                        common.errorHandler({ id: data.id, error: _context13.t0 });
                        return _context13.abrupt('return');

                    case 16:

                        common.response({
                            id: data.id,
                            type: _constants.RESPONSES.SUBSCRIBE,
                            payload: true
                        });

                    case 17:
                    case 'end':
                        return _context13.stop();
                }
            }
        }, _callee13, undefined, [[1, 12]]);
    }));

    return function unsubscribe(_x12) {
        return _ref13.apply(this, arguments);
    };
}();

var unsubscribeAddresses = function () {
    var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14(addresses) {
        var subscribed, request, api;
        return _regenerator2.default.wrap(function _callee14$(_context14) {
            while (1) {
                switch (_context14.prev = _context14.next) {
                    case 0:
                        subscribed = common.removeAddresses(addresses);
                        request = {
                            // stream: ['transactions', 'transactions_proposed'],
                            accounts: addresses,
                            accounts_proposed: addresses
                        };
                        _context14.next = 4;
                        return connect();

                    case 4:
                        api = _context14.sent;
                        _context14.next = 7;
                        return api.request('unsubscribe', request);

                    case 7:

                        if (subscribed.length < 1) {
                            // there are no subscribed addresses left
                            // remove listeners
                            api.connection.removeListener('transaction', onTransaction);
                            // api.connection.off('ledgerClosed', onLedgerClosed);
                            common.removeSubscription('transaction');
                        }

                    case 8:
                    case 'end':
                        return _context14.stop();
                }
            }
        }, _callee14, undefined);
    }));

    return function unsubscribeAddresses(_x13) {
        return _ref14.apply(this, arguments);
    };
}();

var unsubscribeBlock = function () {
    var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15() {
        var api;
        return _regenerator2.default.wrap(function _callee15$(_context15) {
            while (1) {
                switch (_context15.prev = _context15.next) {
                    case 0:
                        if (common.getSubscription('ledger')) {
                            _context15.next = 2;
                            break;
                        }

                        return _context15.abrupt('return');

                    case 2:
                        _context15.next = 4;
                        return connect();

                    case 4:
                        api = _context15.sent;

                        api.removeListener('ledger', onNewBlock);
                        common.removeSubscription('ledger');

                    case 7:
                    case 'end':
                        return _context15.stop();
                }
            }
        }, _callee15, undefined);
    }));

    return function unsubscribeBlock() {
        return _ref15.apply(this, arguments);
    };
}();

var disconnect = function () {
    var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16(data) {
        return _regenerator2.default.wrap(function _callee16$(_context16) {
            while (1) {
                switch (_context16.prev = _context16.next) {
                    case 0:
                        if (_api) {
                            _context16.next = 3;
                            break;
                        }

                        common.response({ id: data.id, type: _constants.RESPONSES.DISCONNECTED, payload: true });
                        return _context16.abrupt('return');

                    case 3:
                        _context16.prev = 3;
                        _context16.next = 6;
                        return _api.disconnect();

                    case 6:
                        common.response({ id: data.id, type: _constants.RESPONSES.DISCONNECTED, payload: true });
                        _context16.next = 12;
                        break;

                    case 9:
                        _context16.prev = 9;
                        _context16.t0 = _context16['catch'](3);

                        common.errorHandler({ id: data.id, error: _context16.t0 });

                    case 12:
                    case 'end':
                        return _context16.stop();
                }
            }
        }, _callee16, undefined, [[3, 9]]);
    }));

    return function disconnect(_x14) {
        return _ref16.apply(this, arguments);
    };
}();

var onNewBlock = function onNewBlock(event) {
    common.response({
        id: -1,
        type: _constants.RESPONSES.NOTIFICATION,
        payload: {
            type: 'block',
            payload: {
                block: event.ledgerVersion,
                hash: event.ledgerHash
            }
        }
    });
};

var onTransaction = function onTransaction(event) {
    if (event.type !== 'transaction') return;

    var subscribed = common.getAddresses();
    var sender = subscribed.indexOf(event.transaction.Account);
    var receiver = subscribed.indexOf(event.transaction.Destination);

    if (sender >= 0) {
        common.response({
            id: -1,
            type: _constants.RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: utils.transformTransactionEvent(subscribed[sender], event)
            }
        });
    }

    if (receiver >= 0) {
        common.response({
            id: -1,
            type: _constants.RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: utils.transformTransactionEvent(subscribed[receiver], event)
            }
        });
    }
    /*
    const status = event.validated ? 'confirmed' : 'pending';
    const hash = event.transaction.hash;
    const signature = event.transaction.TxnSignature;
    const amount = event.transaction.Amount;
    const fee = event.transaction.Fee;
    const total = new BigNumber(amount).plus(fee).toString();
     const txData = {
        status,
        timestamp: event.transaction.date,
        blockHeight: 0,
         inputs: [{ addresses: [event.transaction.Account] }],
        outputs: [{ addresses: [event.transaction.Destination] }],
         hash,
        amount,
        fee,
        total,
    };
     if (sender >= 0) {
        common.response({
            id: -1,
            type: RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: {
                    type: 'send',
                    descriptor: event.transaction.Account,
                    ...txData,
                }
            }
        });
    }
     if (receiver >= 0) {
        common.response({
            id: -1,
            type: RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: {
                    type: 'recv',
                    descriptor: event.transaction.Destination,
                    ...txData,
                }
            }
        });
    }
    */
};

// postMessage(1/x); // Intentional error.
common.handshake();

// // Testnet account
// // addr: rGz6kFcejym5ZEWnzUCwPjxcfwEPRUPXXG
// // secret: ss2BKjSc4sMdVXcTHxzjyQS2vyhrQ

// // Trezor account
// // rNaqKtKrMSwpwZSzRckPf7S96DkimjkF4H

// rpNqAwVKdyWxZoHerUzDfgEEobNQPnQgPU

// rJb5KsHsDHF1YS5B5DU6QCkH5NsPaKQTcy - exachnge

// rsG1sNifXJxGS2nDQ9zHyoe1S5APrtwpjV - exchange2

// from: https://i.redd.it/zwcthelefj901.png